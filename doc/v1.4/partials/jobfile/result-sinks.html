<section>
  <h3>Result Sinks<br /><small>Doing Stuff with Job Run Output</small></h3>

  <p>A run of a job results in one of three events:</p>
  <table class="table">
    <tr>
      <td><dfn>Job success</dfn></td>
      <td>The job (or, specifically, the shell script that the job runs)
        exited with status 0</td>
    </tr>
    <tr>
      <td><dfn>Job error</dfn></td>
      <td>The job (or, specifically, the shell script that the job runs)
        exited with a non-0 status</td>
    </tr>
    <tr>
      <td><dfn>Job failure</dfn></td>
      <td>Jobber stopped scheduling runs of the job due to one or more job
        errors</td>
    </tr>
  </table>

  <p>For a partiular job, you can assign <dfn>result sinks</dfn>
   that can do various things with the job&rsquo;s output in response to these
   events, using the <code>notifyOnSuccess</code>, <code>notifyOnError</code>,
   and <code>notifyOnFailure</code> fields in the job&rsquo;s definition:</p>

   <pre>
jobs:
  GetAirQuality:
    cmd: /home/bob/get-air-quality.sh
    time: 0 0 8
    onError: Backoff
    notifyOnSuccess:
      - type: program
        path: /home/bob/text-air-quality.sh
    notifyOnFailure:
      - type: system-email
      - type: filesystem
        path: /home/bob/jobber-failures
        data:
          - stdout
          - stderr
        maxAgeDays: 10
</pre>

   <p>In this example, result sinks are used only for successes and failures.
     The <code>notifyOnSuccess</code>, <code>notifyOnError</code>, and
     <code>notifyOnFailure</code> fields take lists of result sink definitions,
     and each result sink definition has a required <code>type</code> field as
     well as other fields depending on the type.</p>

   <p>It is common to want to use the same result sink in different jobs (or even
     for different events from the same job).  This is best done by moving the
     sink&rsquo;s definition to the <code>resultSinks</code> section of the jobfile
     and then using YAML anchors in the job definitions to reference the sink&rsquo;s
     definition:</p>

     <pre>
jobs:
  GetAirQuality:
    cmd: /home/bob/get-air-quality.sh
    time: 0 0 8
    onError: Backoff
    notifyOnSuccess:
      - type: program
        path: /home/bob/text-air-quality.sh
    notifyOnFailure:
      - type: system-email
      - *filesytemFailureSink

  DailyBackup:
    cmd: /usr/local/bin/backup /home/bob/documents
    time: 0 0 13
    onError: Stop
    notifyOnFailure:
      - *filesytemFailureSink

resultSinks:
  - &filesytemFailureSink
    type: filesystem
    path: /home/bob/jobber-failures
    data:
      - stdout
      - stderr
    maxAgeDays: 10
</pre>

  <p>Here are the types of result sinks:</p>
  <table class="table">
    <thead>
      <tr><th>Type</th><th>Behavior</th><th>Params</th></tr>
    </thead>
    <tbody>
      <tr>
        <td>system-email</td>
        <td>Sends an email using <code>sendmail</code> to the job&rsquo;s owner
        containing details of the run (e.g., stdout output, stderr output, exit code).</td>
        <td>None</td>
      </tr>
      <tr>
        <td>stdout</td>
        <td>Writes a run record (see below) to jobberrunner&rsquo;s stdout.
        This is useful mostly when running Jobber in a Docker container.</td>
        <td>
          <table class="table">
            <tr>
              <td><code>data</code></td>
              <td>A list of strings each of which must be &ldquo;stdout&rdquo; or
                &ldquo;stderr&rdquo;.  This specifies whether the run record
                written to jobberrunner&rsquo;s stdout will contain the run&rsquo;s
                stdout output, stderr output, or both.</td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>socket</td>
        <td>Writes a run record (see below) to incoming connections to a TCP or
          Unix socket.  This result sink causes
          jobberrunner to listen for connections on the specified socket.
          <br /><br />
      NOTE: The owning user must have permission to listen to the specified socket or
     make a Unix socket at the specified path.</td>
        <td>
          <table class="table">
            <tr>
              <td><code>proto</code></td>
              <td>A string: &ldquo;tcp&rdquo;, &ldquo;tcp4&rdquo;, &ldquo;tcp6&rdquo;,
                or &ldquo;unix&rdquo;</td>
            </tr>
            <tr>
              <td><code>address</code></td>
              <td>A string: either a port specification like &ldquo;:1234&rdquo;
                (specifying on which port to listen) or a filesystem path
                (specifying where to make the Unix socket).</td>
            </tr>
            <tr>
              <td><code>data</code></td>
              <td>A list of strings each of which must be &ldquo;stdout&rdquo; or
                &ldquo;stderr&rdquo;.  This specifies whether the run record
                written to the socket will contain the run&rsquo;s
                stdout output, stderr output, or both.</td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>program</td>
        <td>Runs a program and writes a run record (see below) to the program&rsquo;s
        stdin.</td>
        <td>
          <table class="table">
            <tr>
              <td><code>path</code></td>
              <td>A filesystem path to the program.</td>
            </tr>
            <tr>
              <td><code>runRecFormatVersion</code></td>
              <td></td>
            </tr>
          </table>
        </td>
      </tr>
      <tr>
        <td>filesystem</td>
        <td>Writes the run&squo;s stdout output, stderr output, or both to the filesystem.
        A path to a directory must be given.  The stdout output and stderr output will be written
      to separate files with timestamps as names, and these files will be
      organized by job name.  For example:
    <pre>
- /some/dir/
  - JobOne/
    - 1521318351.stdout
    - 1521318351.stderr
    - 1521318411.stdout
    - 1521318411.stderr
    - 1521318471.stdout
    - 1521318471.stderr</pre>

    </td>
        <td>
          <table class="table">
            <tr>
              <td><code>path</code></td>
              <td>A path to a directory.</td>
            </tr>
            <tr>
              <td><code>data</code></td>
              <td>A list of strings each of which must be &ldquo;stdout&rdquo; or
                &ldquo;stderr&rdquo;.  This specifies whether the stdout outout,
                stderr output, or both will be written.</td>
            </tr>
            <tr>
              <td><code>maxAgeDays</code></td>
              <td>How many days to keep the output files.</td>
            </tr>
          </table>
        </td>
      </tr>
    </tbody>
  </table>

  <p>Several types of result sinks publish details about a job&rsquo;s run in
    the form of a <dfn>run record</dfn>, which is a JSON document.  Here is an example:</p>

  <pre>
{
  "version": "1.4",
  "job": {
    "name": "DailyBackup",
    "command": "/usr/local/bin/backup /home/bob/documents",
    "time": "0 0 13 * * *",
    "status": "Good"
  },
  "user": "bob",
  "startTime": 1543150800,
  "succeeded": true,
  "stdout": "Backing up...\nSuccess",
  "stderr": ""
}
</pre>

<p>If the run&rsquo;s stdout (or stderr) output contained non-UTF-8 bytes, then
  the run record will have a <code>stdoutBase64</code> (or <code>stderrBase64</code>) field
  instead of a <code>stdout</code> (or <code>stderr</code>) field, containing
  the output encoded in Base64.</p>
</section>
